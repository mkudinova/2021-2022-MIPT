#include<stdio.h>
#include<stdlib.h>

typedef int Data;
struct Node {
	Data val; // хранит какое-то значение
    struct Node * next; // указатель на следующий элемент
};
struct List {
	struct Node * head; // будет указателем на начало списка (т.е. на первый элемент)
};
// вместо структуры можно было бы сделать просто переменную (глобальную, или локальную переменную main),
// где хранить адрес начала списка
// например, struct Node * p_head = NULL;

// необходимые действия для создания и инициализации списка:
// выделить память под структуру, присвоить голове указатель на NULL.
struct List * list_create (){
	struct List * p = (struct List*)malloc(sizeof(struct List)); // выделили память
	p->head = NULL; // изначально список пуст
	return p;
}
// По условию задачи указатель на начало (голову) списка хранят в структуре List, определяющей список
// => в функциях list - указатель на структуру типа List,
// и list->head будет указателем на самый первый элемент списка

// кладет число х первым (выделив под него память) элементом списка
void list_add_first (struct List * list, Data x){
	struct Node *p = (struct Node*)malloc(sizeof(struct Node)); // выделили память под этот элемент
	p->val = x; // записали число в поле val созданного элемента
	p->next = list->head;
	// p->next - поле next созданной структуры p, должно хранить указатель на следующий элемент
	// Если в списке уже был первый элемент, то теперь он станет вторым,
	// т.е. следующим за тем, который мы вставляем.
	// p->next = NULL; - означало бы, что следующего элемента нет,
	// но в этом случае и list->head было бы равно NULL
	list->head = p; // записали адрес нового элемента в указатель на начало списка
	return;
}

// кладет число х (выделив под него память) последним элементом списка
void list_add_last (struct List * list, Data x){
    struct Node *p = (struct Node*)malloc(sizeof(struct Node)); // выделили под него память
    p->val = x; // записали в него значение
    p->next = NULL; // сказали, что за ним никаких элементов нет - он последний

	// ищем, куда его вставить - рассматриваем варианты:
	
	// 1) если список был пуст, этот элемент становится первым
	if(list->head == NULL){
		list->head = p;
		return;
	}
	
	// 2) если список не был пуст, то есть содержал по меньшей мере один элемент,
	// то ищем последний элемент списка - т.е. такой, у которого указатель next на следующий равен NULL 
	struct Node * q = list->head; // для этого создаем временный указатель
	// будем его использовать для прохода по списку и перебора элементов 
	while(q->next !=NULL){ // до тех пор, пока не встретим элемент q, такой что для него q->next == NULL
		q = q->next; // переходим на следующий элемент
	}
	// в этот момент: q->next == NULL => q - указатель на последний элемент списка
	q->next = p; // теперь q содержит указатель на p === вставили p в конец списка

	return;
}
// достает первое число из списка и возвращает его (перед возвратом освободив из-под него память)
Data list_remove_first (struct List * list){
	if(list->head == NULL){ // проверка - вдруг в списке не было элементов
		printf("Error");
		return -1;
	}
	
	struct Node * p_temp = list->head; // сохраним адрес первого элемента во временной переменной,
	// чтобы можно было освободить память, после того, как list->head (указатель на начало списка) будет перезаписан
	Data Y = p_temp->val; // сохраним значение этого элемента, чтобы вернуть его после того, как освободим память
	list->head = p_temp->next; // в указатель на начало списка запишем указатель на тот элемент,
	// который раньше следовал до тем, который мы удаляем
	free(p_temp); // освободим память
	return Y; // вернем значение
}

// достает последнее число из списка и возвращает его (перед возвратом освободив из-под него память)
Data list_remove_last (struct List * list){
	if(list->head == NULL){ // проверка - вдруг в списке не было элементов
		printf("Error");
		return -1;
	}
	
	// ищем предпоследний элемент
	// последний нужно будет удалить, а в предпоследнем выставить в NULL указатель на следующий
	
	// если элемент был всего один:
	// list->head - указатель на первый элемент,
	// list->head->next поле next первого элемента, хранящее указатель на следующий,
	// list->head->next == NULL - следующего нет)
	// значит, удаляем первый элемент, и в list->head пишем NULL (список теперь пуст)
	if(list->head->next == NULL){
		Data Y = list->head->val; // сначала сохраним значение, которое надо будет вернуть
		free(list->head); // освободим память
		list->head = NULL; // элементов больше нет
		return Y;
	}

	// элементов в списке боле одного, ищем предпоследний
	struct Node * q = list->head; // начинаем с первого элемента
	// q - адрес текущего, q->next адрес следующего,
	// q->next->next - поле next в следующем, если оно == NULL, значит, следующий = последний
	while(q->next->next !=NULL){ // пока не встретим предпоследний элемент
		q = q->next; // переходи на следующий
	}
	// в этот момент q->next->next == NULL => мы нашли предпоследний
	Data Y = q->next->val; // сохранили значение из последнего
	free(q->next); // освободили память из под последнего
	q->next = NULL; // в предпоследнем изменили поле next, теперь после него элементов нет
	return Y;
}

// распечатывает через пробел числа, лежащие в списке.
// только основная суть, без форматирования
void list_print (struct List * list){
	struct Node * q = list->head; // q - будет указателем на текущий элемент
	while(q != NULL){
		printf("%d ", q->val);
		q = q->next; // переходим на следующий
	}
	return;	
}


//////////////////////////////////////////////////////////////////////////////
/*В двусвязном списке каждый элемент хранит указатель и на следующий, и на предыдущий.
=> Вставка в середину будет выглядеть примерно так:
если вставляем сразу после элемента с адресом q

// выделить память
struct Node * p = (struct Node*)malloc(sizeof(struct Node)); 

// заполнить поля
p->val = 5;
p->prev = q; // вставляем сразу после q
p->next = q->next; // тот, который раньше шел сразу после q, теперь будет идти после нового

// поменять указатели внутри соседних элементов
q->next->prev = p; // q->next - пока еще тот, который раньше шел сразу после q, => заполняем поле prev в нем
q->next = p; // меняем поле next в q
*//////////////////////////////////////////////////////////////////////////////

// пример работы
int main(){
	struct List * list = list_create();
	list_add_first(list, 5);
	list_add_first(list, 3);
	list_add_last(list, 7);
	list_add_last(list, 8);
	list_add_last(list, 9);
	list_print(list);
	printf("\n");
	printf("size = %d\n", list_size(list));
	printf("%d\n", list_remove_first(list));
	printf("%d\n", list_remove_last(list));
	list_print(list);
	printf("\n");
	list_destroy(list);
}
