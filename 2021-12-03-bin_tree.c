#include<stdio.h>
#include<stdlib.h>

struct Elem {
	int val; // значение, которое хранится в элементе ((!) может быть указателем на строку, например)
	struct Elem * lv, * pr; // указатели на левого и правого потомков
};
struct Elem * root; // глобальная переменная, хранящая указатель на начало дерева

void print_tree(struct Elem * p){ // рекурсивный обход дерева в глубину
	if (p == NULL){
		return;
	}
	
	print_tree(p->lv); // распечатать левое поддерево все целиком
	printf("%d ", p->val); // распечатать значение текущего элемента
	print_tree(p->pr); // распечатать правое поддерево все целиком
	
	return;
}

void add_elem(int x){
	struct Elem * p = (struct Elem *)malloc(sizeof(struct Elem)); // выделить под элемент память
	p->val = x; // заполнить его поля
	p->lv = NULL;
	p->pr = NULL;
	
	// ищем для него подходящее место в дереве
	// если дерево пусто
	if (root == NULL){
		root = p;
		return;
	}
	
	// если дерево не пусто, ищем для него родительский элемент (вставляем только как лист)
	struct Elem * q = root;
	while(1){
		if (x < q->val){ // если x меньше, чем значение текущего элемента, то вставляем в левое поддерево
			if (q->lv != NULL){
				q = q->lv; // переходим в левого потомка текущего элемента
			}
			else{
				q->lv = p; // вставляем новый элемент, если левого потомка не было
				break;
			}
		}
		else{ // если x больше или равно, то - в правое поддерево
			if (q->pr != NULL){
				q = q->pr; // переход в правого потомка
			}
			else{
				q->pr = p; // вставка в качестве правого потомка
				break;
			}
		}
	}

	return;
}

struct Elem * find_elem(int x){ // проход по дереву в этом случае аналогичен add_elem
	if (root == NULL){
		printf("Empty tree");
		return NULL;
	}
	
	struct Elem * p = root; // p - будет указателем на текущий элемент на каждой итерации
	while(1){
		if(x == p->val) // если значение совпало - мы нашли нужный элемент
			return p;
		if(x < p->val){ // если x меньше, идем искать в левом поддереве
			if(p->lv != NULL)
				p = p->lv; // если левое поддерево есть - переходим левого потомка
			else
				return NULL; // если левого поддерева нет - значит не нашли нужный элемент
		}
		if(x > p->val){ // если x больше, идем искать в правом поддереве
			if(p->pr != NULL)
				p = p->pr;
			else
				return NULL;
		}
	}
	
	return NULL;
}

// пример
int main(){
	root = NULL;
	add_elem(7); // вставим в корневой элемент
	add_elem(5); // пойдет как левый потомок 7
	add_elem(8); // пойдет как правый потомок 7
	add_elem(6); // пойдет как правый потомок 5
	add_elem(3); // пойдет как левый потомок 5
	add_elem(1); // пойдет как левый потомок 3
	add_elem(4); // пойдет как правый потомок 3
	add_elem(9); // пойдет как правый потомок 8
	print_tree(root); // распечатать все дерево целиком
	printf("\n");
	print_tree(find_elem(3)); // распечатать поддерево с корнем в элементе, имеющим значение = 3
	
	// дерево в таком случае выглядит так:
	// .......7.......
	// ...5.......8...
	// .3...6.......9.
	// 1.4............
	return 0;
}
